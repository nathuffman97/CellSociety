## Introduction

The main problem our team is trying to solve by writing this program is creating the animation for any 2D CA simulation in JavaFX. In this simulation, each the state of each cell should be updated simultaneously according to the rules set by a user in an XML file. These rules will include the game type, which will include segregation, predator-prey, fire, and game of life. We plan to have separate classes that control the user interface, reading the XML file, the animation, and the cell types depending on the game. The cell types and XML file reading should be pretty flexible because the user should be able to change the parameters of the XML file should he or she desire. The user should also be able to write a new inherited cell type class if he/she would like to implement new rules. Since the results of the XML file reading and cell type classes are important for running the game, they will have some methods publicly available to the main class. This will also be true for the user interface class.

## Overview

![Overview]
(https://coursework.cs.duke.edu/CompSci308_2017Fall/cellsociety_team12/blob/master/doc/Overview.jpg "Overview")

The main class launches the application. When the user chooses to start the cell simulation application, the Game class will set up the stage and the scene for the game. The Util class will be called to read the XML file containing important information about the game, like the size of the grid and the game type. The UI class will manage controls in the first scene that the user will have access to, like pausing the simulation or restarting, that will be elaborated more on in the UI section. Some examples of methods that will be in the UI class are a private handlePause() method if the user pauses the game, a print instruction method, and a start method, which will be called from the main overridden start method. The Util class will have a method, parse, that will put the game parameters into a collection used in the game set up in the Game class.

The Game class will have the step method or animation. Methods for handling interruption to the simulation, like if the user uploads a new XML file to be parsed or pauses the game, will be handled in the UI class since it manages all of the user buttons and interactions with the simulation. The rules for how the cells move will be handled in another class called CellGroup. CellGroup will contain the 2D array of all the cells, the type of simulation occurring, the root of the scene, and the inherited classes cell and cell type. The cell class is an abstract class that will contain information about a cell, like its color and movement patterns. Each of these subclasses are called CellTypes. The cells’ movement patterns will be determined depending on the simulation. Some methods a part of the cell class will include die() and spread(). 

## User Interface

A rough picture of the user interface can also be found in the picture of the overall layout of the program. Along the side of the simulation will be various buttons and sliders the user can click and adjust to see how different parameters affect the simulation. There will be a button for uploading a new file and restarting the game with those configurations, a pause/resume button, a step button to step through the simulation, a slider to control the speed of the animation, and text fields describing the current states of the 2D grid. All of these functions will be handled by the UI class. There also shouldn’t be any erroneous situations given to the user since the simulations will be set up to avoid such problems.

## Design Details

### Class Overview

The main class will only create a `Game` instance, passing it *args* to launch the program with.

The `Game` class will extend `Application` and act as main display for the UI and cell grid as well as the liason between the two. Once called from main, it opens a window and calls on `UI` to set itself up. When `CellGroup` gets intitialized, it also adds the visual representation of all cell states to the window and updates the text outlining the rules of the current simulation. 

| Method Signature                    | General Purpose                                                       |
|-------------------------------------|-----------------------------------------------------------------------|
| **public** Game(String[] args)      | Creates a new game window by calling launch(args)                     |
| **private void** step(double speed) | Run one update of the cell array at the speed chosen by the UI slider |

   
   
The `UI` class will handle inputs and controls like button presses or slider inputs. To extend `UI` to add new features, like manual input of values, the class just needs more buttons that will push different information to `CellGroup` through the same channels of *update()* or *createCellGroup()*, which should help make the extension simple. This class relies on an XML file in data containing the overall layout of the buttons and sliders, as well as an XML file representing the game rules and game configuration for *loadNewFile()* to access. It also needs the Util classs to use its *xmlParse()* method to get useful information from these files. Below is a list of method signatures in the class, as well as a brief description of their purpose:


|                             Method Signature                            |                                                    General Purpose                                                   |
|:-----------------------------------------------------------------------:|:--------------------------------------------------------------------------------------------------------------------:|
|                             **public** UI()                             |                                                      Constructor                                                     |
|      **private Button** makeButton(String text, double x, double y)     |                            Creates and returns the desired button at the desired location.                           |
| **private Slider** makeSlider(double min, double max, double incrament) |                            Creates and returns the desired slider at the desired location                            |
|      **private void** displayRules(String text, double x, double y)     |        Prints flavor text for each type of simulation on the UI box. Changes based on which rule set is used.        |
|                      **private void** handlePause()                     |                                                  Stops the animation                                                 |
|                     **private void** handleResume()                     |                                           Resumes or launches the animation                                          |
|                   **private double** handleAlterTime()                  |                  Modifies the value of *elapsedTime* based on the current state of the speed slider                  |
|                  **private void** createCellGroup()                     |         Calls the `Game` constructor with arguments from *loadNewFile()* and sets other parameters for the game        |
|                      **public void** start(Stage s)                     |                                         Required to extend application, will                                         |
|                 **public void** step(double elapsedTime)                |                            Calls *makeButton()* and *makeSlider()* to set up UI controls.                            |
|                      **public void** loadNewFile()                      | Opens an XML file using the JavaFX `FileChooser` class containing the game set up details and processes it with *Util.xmlParse()* before passing this information to *createCellGroup()*   |



The `CellGroup` class control the behavior of multiple cells and moderate their interaction by curationg and polling a collection of `Cell.Cell` objects, returning any relevant information about the group's state to `Game` for display. Storing the cells in some arbitrary collection and letting the individual cells keep track of their neighbors give flexibility for if the desired cell group shape is a something like a big circle rather than a square, as it helps protect against null pointer exceptions. This class depends on the `Game` and `Util` classes to read an XML file and pass it the information it contained in  that file.

| Method Signature                                         | General Purpose                                                                                                                  |
|----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|
| **public** CellGroup(int width, int height, int simType, double probUpdate) | Creates the array of cells and fills it with calls to *initCell()*                                                               |
| **public String[]** update()                             | Has all the cells that might change state update themselves based on their neighbors, returns a String[] of information about the group to UI to display |
| **private void** initCell(int state, double probUpdate)                     | Creates a cell with a specified state and spread likelyhood. This number will mean different things for different cell sub-classes.                    |

The `Cells` class is abstract, and while there might be some concerte methods common between all cells, most of the implemention will be done by its children, `FireCell`, `LifeCell`, `PredPreyCell`, and `SegCell`. Each rule type will have its own cell sub-class that use *update()* to possibly change the cell's state based on the specific requirements for that rule set. For example, `FireCell` might have an *update()* method that will cause a cell to catch fire if its neighbor is burning and it succeeds on a *probCatch* roll, while a `LifeCell` would update if three of its neighbors are alive and it's dead. This makes the program extremely flexible, since a new simulation type just requires a new class built on an exisiting framework. It depends on the `CellGroup` to organize it and curate the group behavior like updates or overall status, as well as the XML file that specifies its specific child class type.

|            Method   Signature            |                                                 General Purpose                                                 |
|:----------------------------------------:|:---------------------------------------------------------------------------------------------------------------:|
|         **public** Cell.Cell(int state, double probUpdate)           |        Creates a new cell with a specified state. The int means something different for each sub class, and probUpdate specifies how likely it is to update if conditions are met       |
| **public boolean** update() | Returns true if cell does update, false if not. Each sub class will   implement based on the specified rule set |
|         **public int** getCellState()        |                                                Returns cell state                                               |
|         **public void** changeState()        |                                    Updates the cell if it needs to update so all cells check for updates with the same information |

The `Util` class will have a public static method *parseXML()* that takes in a filename as a String and returns a collection of the values inside that XML file as Strings. It likely needs helper methods to allow it work, so the work might get split into subtasks like openning the file, reading the strings, and assembling the data. It shouldn't depend on any resources or classes, and by splitting the tasks into helper methods, a file formating change to something like JSON could be easily accomidated in the future.

### Use Cases
1. `CellGroup` will call on each cell to check the status of its neighbors, and based on that the cells will determine if it needs to update. If it does, it will update when the generation progresses, and if not it keeps its state the same.
2. Exactly the same as for the middle case, since the cells are initialized knowing their neighbors so being at the edge makes no difference.
3. `CellGroup` iterates over the collection of cells that have already checked for their update status, if they are flagged for update, the cells change state and reset their *toUpdate* flag, else the cell does nothing.  
4. Cells are intialized with a double for probability of spread occuring if the spread conditions are met that ranges from 0 to 1. The XML file will have a field for *probCatch* under the cell heading, declared with \<probUpdate\>. When `Game` calls on `CellGroup` to create the cells, it will pass this parsed value to the cell constructor.
5. In the UI, click the "Choose File..." button and select a new file, then press the "Launch" button to load the new simulation. This will call *clearScreen()*, *loadNewFile()*, and *createCellGroup* to remove the old simualtion and in its place set up a new simulation using the same method calls to set up the first simulation.

## Design Considerations

The biggest design choice that our team discussed was where to put the subclasses pertaining to different simulations. We ultimately decided on putting them under the Cell.Cell class, but we strongly considered putting them under the CellGroup class. The subclasses in either scenario would contain the specific rules associated with that simulation. We just struggled to decide whether those rules should be contained in the CellGroup class or the Cell.Cell class. Putting them in the former made some sense, as it meant that the interaction between the cells was controlled at a higher level. This way, the cells would not be making calls to each other to get their states and so their information could be kept private among each other and would be known only to the higher CellGroup class. Additionally, we were concerned about inefficiencies if the cells were calling each other to get their neighbor’s states. This would mean that most cells would be called four times (four neighbors), returning the same information each time, which seemed redundant. However, the downside of this implementation was that it left very little to be done in the Cell.Cell class, meaning the Cell.Cell class was acting more like data storage than actually performing any action. 

The other option was to put the subclasses under the Cell.Cell class. Having subclasses at the lowest level of the game is an intuitive way to structure a program and the rules provided by the different simulations did seem less relevant to the group as a whole and more relevant to individual interactions between cells. The pros and cons of this implementation align with the cons and pros above-- this avoided the problem of the Cell.Cell class being data storage by making it more active, but it did mean that slight redundancy of asking a cell for the same information remained. We ultimately decided that the latter problem was slight compared to the conceptual trouble of crippling the Cell.Cell class by not allowing it to execute its own updates. We decided to have the CellGroup move through all of the Cells and tell them when to update, but the Cell.Cell subclasses will actually execute their own updates, based on stored information of who their neighbors are.

Another design consideration that we spent a good deal of time discussing was the overlap between the Game and the UI class. We felt fairly strongly that, because this project includes parts of the scene that the user interacts with (pause button, speed slider, etc) that there should be a UI class separate from the Game class. Originally, we had the Main class create an instance of the UI class, which drew the scene and created a Game instance. However, this meant that there was very little code actually in the Game class-- it basically only created a CellGroup object and passed information to it that it had received from the UI class. It seemed pointless to have this in-between class that did nothing, but we liked the idea of a class that controlled the gameplay, separate from just drawing the scene. To move gameplay execution into the UI class when it was irrelevant there didn’t sit well with us. Instead, we changed the order of the Game and the UI class. In our current plan, the Main class creates an instance of the game class, which launches the scene and starts the animation. It calls the UI class, which draws the elements of the scene that the user interacts with and monitors them for user input (which, if received, is passed back to the Game class). This setup allowed for a Game class to act as a conceptual intermediary, without it being useless practically.

## Team Responsibilities

Because our program consists of six classes (with the exception of the cell subclasses), we decided to split up the project by class. Matt will take primary responsibility for the Cell.Cell super- and subclasses; Owen, the UI and Util classes; and Natalie, the Game and CellGroup classes. To begin with, we will focus on completing these classes separately, based on the public methods we already decided on for each class. Whenever anyone finishes working, they will submit a merge request on their branch and wait for a different member of the group to review and approve it. The purpose of this is to minimize the likelihood of one group member writing code that breaks already approved code. The tentative goal is to get the basic program working by halfway to the first deadline. We will then spend the other half of the time reviewing and suggesting refactoring for each other’s code.  Once the basic implementation due date has passed, we will re-delegate tasks based on the new information and a group consensus of the amount of work left to be accomplished.
